\section{Introduction to Grammar}
This section will explain on how the grammar for the syntax language will be generated and the reason for why each part of the language was made as it is. 

\subsection{Context Free Grammar (ANTLR4)}
Context free grammar describes the syntax of the language. ANTLR4 which is the parser generator for this language has it's own version of EBNF (Extended Backusâ€“Naur form) it uses to implement the syntax.
The different annotation used in order to express EBNF can be seen in the table below.
\begin{center}
\begin{tabular}{ |c|c| } 
 \hline
 ? & Zero or one occurrence\\ 
 \hline
 | & One or the other \\ 
 \hline
 * & Zero or more occurrence \\ 
 \hline
  + & One or more occurrence \\ 
 \hline
\end{tabular}
\end{center}


\begin{verbatim}
start
    : dcls stmts EOF
    |
    ;
dcls
    : dcl*
    ;
dcl
    : type ID
    ;
stmts
    : stmt*
    ;
stmt
    : assign_stmt
    | while_stmt
    | func_call
    | func_def
    | if_stmt
    ;
assign_stmt
    : ID ASSIGN expr
    ;
primaryExpr
    : val
    | BOOL
    | func_call
    ;
parenthesisExpr
    : primaryExpr
    | '(' expr ')'
    ;
unaryExpr
    : parenthesisExpr
    | operator=('-'|'!') parenthesisExpr
    ;
multiplicativeExpr
    : unaryExpr
    | multiplicativeExpr operator=('*'|'/') unaryExpr
    ;
additiveExpr
    : multiplicativeExpr
    | additiveExpr operator=('+'|'-') multiplicativeExpr
    ;
relationalExpr
    : additiveExpr
    | relationalExpr operator=('<'|'>'|'<='|'>=') additiveExpr
    ;
equalityExpr
    : relationalExpr
    | equalityExpr operator=('='|'!=') relationalExpr
    ;
logicalAndExpr
    : equalityExpr
    | logicalAndExpr 'AND' equalityExpr
    ;
logicalOrExpr
    : logicalAndExpr
    | logicalOrExpr 'OR' logicalAndExpr
    ;
expr
    : logicalOrExpr
    ;
func_def
    : FUNCTION type? ID parameters block;
func_call
    : ID '('func_call_param')'
    ;
func_call_param
    : expr? | expr(','expr)+
	;
val
    : ID
    | INTEGER
    | DOUBLE
    | STRING
    ;
type
    : INTDCL
    | DOUBLEDCL
    | BOOLEANDCL
    | STRINGDCL
    ;
return_stmt
    : RETURN expr?
    ;
if_stmt
    : IF '('expr')' block
    | IF '('expr')' block ELSE block
    ;
while_stmt
    : WHILE '('expr')' block
    ;
parameters
    : '('dcl?(','dcl)*')'
    ;
block
    : '{'dcls stmts return_stmt?'}'
    ;

// DECLARATIONS
INTDCL              : 'int' ;
DOUBLEDCL           : 'double' ;
STRINGDCL           : 'string' ;
BOOLEANDCL          : 'boolean' ;
// STATEMENTS
ASSIGN              : ':=' ;
// OPERATORS
PLUS                : '+' ;
MINUS               : '-' ;
DIVIDE              : '/' ;
MULTIPLE            : '*' ;
// LOGICS
NOT                 : '!';
AND                 : 'AND' ;
OR                  : 'OR' ;
EQUAL               : '=' ;
NOTEQUAL            : '!=' ;
LESS                : '<' ;
LESSTHANOREQUAL     : '<=' ;
GREATER             : '>' ;
GREATERTHANOREQUAL  : '>=' ;
// CONDITIONALS
ELSE                : 'else' ;
IF                  : 'if' ;
WHILE               : 'while' ;
RETURN              : 'return' ;
FUNCTION            : 'func' ;
DEFAULT             : 'default' ;
// IDENTIFIERS
BOOL                : 'true' | 'false' ;
ID                  : [a-zA-Z_]+[a-zA-Z0-9_]*;
// DATA TYPES
INTEGER             : [0-9]+ ;
DOUBLE              : [0-9]+'.'[0-9]+ ;
STRING              : '"' (~["\r\n] | '""')* '"' ;
// EXTRA
BLANK               : [ \t\r\n]+ -> skip ;
COMMENT             : '#' ~[\r\n]*-> skip ;
\end{verbatim}
    