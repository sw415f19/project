\section{Concrete and Abstract Syntax Tree}
From the grammar file with the EBNF in Listing \ref{code:ebnf}, ANTLR generates both a lexer and a parser. 
\\\\
However, ANTLR4 can only generate a concrete syntax tree (CST) which is the literal recognition of token in the programming language. Each and every symbol is included in the concrete syntax tree, including terminal symbols like equality signs "\texttt{:=}", parenthesis  "\texttt{()}" and keywords "\texttt{if}". These are named after the terminals and non-terminals in the EBNF file. While one could potentially work with these tokens directly, it's hard to navigate with all the extra tokens on the nodes.
\\\\
To improve this the the concrete parse tree must be converted into an abstract syntax tree (AST). This is done by using the \texttt{BuildAstVisitor} class, which is a subclass of the \texttt{BaseVisitor} provided by ANTLR. The \texttt{BuildAstVisitor} class provides a visitor pattern to traverse through the concrete parse tree nodes. While traversing the nodes, abstract syntax tree nodes are made from the CST nodes.  \\
Seen in \ref{code:visitFuncDef} is a example where a AST node for \texttt{Func\_def} is created. The \texttt{Func\_defContext} has access to text that was parsed. If for example, the syntax text of a CST node was \texttt{func int test() \{\}}, the "\texttt{func}" would be unnecessary for the generated AST node. This is the case since the fact that it is a function definition node will be contained in AST node itself, because the class name of the AST node is \texttt{Func\_defNode}. \\
The other thing that happens in the example is showing how the special functions \texttt{Setup} and \texttt{Loop} are handled when creating the AST. What node is created depends on whether the text of the function definition name is \texttt{Setup}, \texttt{Loop} or some other function definition.
\\
\begin{lstlisting}[caption={Visit method for \texttt{Func\_defContext} in \texttt{AstBuildVisitor}}, label={code:visitFuncDef}]
$$@Override
public AstNode visitFunc_def(EzuinoParser.Func_defContext ctx) {
  String ID = ctx.ID().getText();
  Type type = getType(ctx.type());
  List<DclNode> param = new ArrayList<DclNode>();
  BlockNode block = (BlockNode) ctx.block().accept(this);
  for (DclContext child : ctx.parameters().dcl()) {
    parameters.add((DclNode) child.accept(this));
  }
  switch(ID) {
    case "Setup": return new SetupNode(ID, type, param, block);
    case "Loop": return new LoopNode(ID, type, param, block);
    default: return new Func_defNode(ID, type, param, block);
  }
}
\end{lstlisting}