\section{Code Generation}
Nearing the end of the compiler run, after having done all the contextual analysis described in the different visitor sections, you end up with a Decorated Syntax Tree (DST).\\
This tree has been decorated by all of the visitors previously described and therefore lives up to all rules of the programming language. This means that the DST contains all of the data, the other visitors has decorated the tree with. Because of this, we can now use the DST to generate code.\\
The purpose of this section, is to describe how the Eziuno compiler, uses the DST decorated by all other visitors, to generate code.
\\\\
There can be multiple code generators, as they follow the visitor pattern to generate the code. This is the point where the designer of the compiler decides what target language(s) the compiler should have.
\\\\
There are several different target languages that would be wise to compile to. These could be C, Assembly or Java-bytecode. Considering that our language is intended for home automation purposes, compiling to C isn't a bad idea, as it makes it easier for us to optimize the compiler to be memory or speed effective.\\
Furthermore, the gcc compiler is on many platforms and architectures, making it trivial for us to port it from one platform to another. Java bytecode is also a good option for a target language, as it runs on the JVM, which is implemented on many platforms too, though it should be noted, that java bytecode still works with a class-based structure, meaning we would have to model our imperative language in an object-oriented space.\\
Compiling to an intermediate language is usually a decent idea, as it lets our own language build on top of an already existing compiler-collection, to allow our code to run on many platforms out of the box.\\
Considering that the alternative is to compile to a platform-specific assembly language and that there are better options for us to compile to, we will therefore not be making a platform-specific compiler.
\\\\
A good approach for high level languages is to translate to a intermediate low level language, that already have implementations for most hardware.\\
Implementing a language this way, means that you can implement a code generator for the high level language to target language, which then can be use to generate code for other languages.\\
Doing it this way, means that instead of making a high-level \* low-level number of compilers, you only have to make a High-level \+ Low-level number of compilers.\\
This does add abstraction, but might also add complexity if either the source language or the destination language, implements structures that are hard or impossible to implement.\\
Examples of compilers with intermediate languages are Java and C\#. Java compiles Java Bytecode which is the instruction set of the Java Virtual Machine. C\# compiles to Common Intermediate Language, which is then run on the Common Language Runtime.
\\\\
Looking into the code generation, Ezuino implements three code generator visitors in total. The first one being C Code Generator, which generates C code from the AST visitor. The second one is Arduino C code generator, which has special features from the Arduino library, for example, serial.print and many more. The last one is Java Bytecode generator for Jasmin.\\
As there is a lot of code in these generators, and visitors has been explained in the previous chapter, we will focus on the code generation part from each of these code generator visitors.\\
The first code snippet is from the C code generator visitor, which uses its start node to include the necessary C headers within the generated code : \\
\input{figures/ew/io01.tex}
\noindent\newline

The second case, is where we have the Arduino C code generator.
\input{figures/ew/io02.tex}
\noindent\newline
In example on listing \ref{io02}, we got two visitor function, both the delay node and the digital read node. Each of these will append the special Arduino library functions to the code generator, if it read the function id as both within the buildastvisitor.
\\\\
The last visitor is the Jasmin code generator.\\
Unlike the previous two visitors, the jasmin code generator doesn't compile to a C-like language, but rather to Jasmin, which is an assembler-representation of Java bytecode. This is quite different from parsing to C or Java, as the scoping rules are a bit different, either being completely flat inside a given function, or more of a nested structure if one is using classes and access modifiers.\\
This combined with a register-based storage model means, that the compiler has to manually keep track of the allocated registers, and when it is safe to overwrite a given register with another value. This is currently handled when the Jasmin visitor visits a block node in the AST.\\
The code snippet in question can be seen in listing \ref{code:JasminBlock}. Note that a copy of the variable environment is reset to its pre-block state after the entire block has been generated. This is so that a variable declared in an inner scope will take precedence when being referenced in an expression, compared to a variable of the same name declared previously in an outer scope, while still "deallocating" the inner variables after the block has been processed.
\input{figures/implementation/jasmin-codesnippets/visit_block.tex}

Furthermore, it should be considered that the JVM is a stack machine, and thus it should be taken into consideration, when writing code for it. Though this is mostly a fact to be considered when evaluating expressions, though it is also important when it comes to function calls (or method invocations, as they are parsed down to), as these use the top i elements of the stack as parameters, and then push the return value of the function back on the stack.\\
The stack also plays a role in some of the more complex implementations (namely prints and strings), as these use object references like in Java, but on the stack, like any other value. It isn't terribly hard to write the (java) method invocations, but you do have to keep your wits about you, as the order of the stack matters, and the typing syntax of the JVM gets a bit longer and incomprehensible, when referencing custom types like "String".
