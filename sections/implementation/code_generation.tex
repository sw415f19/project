\section{Code Generation}
Nearing the end, of the compiler, after doing all the contextual analysis, you end up with a decorated syntax tree which has made sure that everything lives up to the programming language that has got defined earlier in this report. Now it’s time for code generation.
Here there can be multiple code generators, as it can follow the visitor pattern to generate the code. This is the point where the designer of the compiler decides what the resulting language of the compiler should be. Whenever it should be C, Assembly, etc. It depends on what we design the programming language for. Sometimes it might be necessary to make some pre-defined code to support the structures and functionality of the programming language.
A good approach might be to create an intermediate language if you want to compile multiple high-level programming languages to a low-level programming language. In that way instead of making many compilers from D => B, E => B, D => C, E => C, you can create one compiler from the high-level language to the intermediate language. If you want to output to multiple low-level languages, you need to add another compiler from the intermediate language to the new low-level language. In that way, instead of making a high-level \* low-level number of compilers, make High-level \+ Low-level number of compilers. It adds abstraction but might also add complexity if either the source language or the destination language has structures that are hard or impossible to implement. Some examples of compilers with intermediate languages are Java and C\#. Java compiles Java Bytecode which is the instruction set of the Java Virtual Machine. C\# compiles to Common Intermediate Language, which is then run on the Common Language Runtime.