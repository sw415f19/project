\subsection{Parser generator tools}
In this section, we used an explanation of what kind of parser generators exist and for the project. To understand the general concept, a parser is an interpreter/compiler, which takes sequences of tokens and translates the tokens that the scanner interprets. An example of a parser is to build a data structure for an AST to a new program language.
The first parser generator the group tried to review was ANTLR 3. ANTLR 3 can either create a tree parser, lexer or parsers. ANTLR3 also use a parsing  technique named LL(*). ANTLR parse generator also has a newer, however, less documented version, ANTLR 4. This version differs from ANTLR 3, because ANTLR 4 creates a general parser tree with either listeners or visitors, which makes it possible to go through the generated tree to find its children \cite{ANTLR4-Why}. It also uses the same parsing technique as ANTLR3. The other parse tool generator that was tested, which were named Coco/R. Coco / R generates a scanner and a parser from the source language and grammar the user has programmed in. The parser that is created is an LL(k), which makes it able to peek at the next symbol k without reading it \cite{COCO/R}. \\
\\
Another parse generator tool that was reviewed, Gold. Gold generates a parser with the LALR parsing algorithm good to discover error recovery and display the information on what happened during the parse phase because the generator knows which token should be expected. GOLD parser generator also supports many programming language which is another good expect of it.\\
To make a parser tree with GOLD, the first step would be to write a file with the grammar for the programming language. After that the GOLD builder will create a parse tables with the LALR parsing technique and check if the created grammar contains any problems or ambiguities, while saving the information into a separate file. If there are some, it will be reported. Once that is done it GOLD could read the created grammar with a parsing engine that can work in different programming languages that GOLD supports \cite{GOLD}. 
\\

In all cases, the source text is analyzed by the parser engine and a parse tree is constructed.
SableCC is another parser generator that can create abstract syntax trees and tree walker classes. The problem with this parser generator is that the only language that the users can write it with is the programming language Java. Other programming language are not supported with SableCC. SableCC uses the LALR(1) parsing\cite{SableCC}.\\
\\
The parser generator that was used in the project was the ANTLR 4, because there was a need of creating a generated AST tree that was able to walk through to check every child it has so that it it could be checked of its value and because it was more user friendly than the other parser generator tools. 
The top-down parsing is where the highest part of the parse tree will recognize the detail and from there on go down the parse tree until it hits and recognize the lowest part of the parse tree, which is the most detailed part, but it also scans the leftmost symbol first before going further down. We use top-down parsing when you want to create a hypothetical parsing tree with unknown data relationship, because the parsing tree would be testable to see if the hypothetical unknown data relationship could work together. The top-down parsing uses the LL(1) parsing, I will explain later which.